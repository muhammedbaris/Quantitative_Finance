# -*- coding: utf-8 -*-
"""public_assets.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FH9C_SWKQ2g6vF4oRIF26fLNgQ2p_idH

I will write a script to create a Monte Carlo Simulator in this python file which simulates multi-asset prtfolio evolution over time.

# 1. Install and Import Required Libraries
"""

# Install yfinance for downloading financial data
!pip install yfinance --quiet

# Install numpy-financial for PrivateAssets
!pip install numpy-financial --quiet


# Import numerical and data manipulation libraries
import numpy as np
import pandas as pd

# Import for data download and visualization
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns

# Set default plot style using Seaborn
sns.set_style("darkgrid")

"""2. Download Historical Monthly Returns for Asset Classes"""

def download_data(tickers, start="2010-01-01", end="2024-01-01"):
    """
    Downloads adjusted monthly close prices for the given tickers
    and calculates monthly returns.
    """
    # Explicitly set auto_adjust to False to ensure 'Adj Close' is returned
    data = yf.download(tickers, start=start, end=end, interval="1mo", auto_adjust=False)

    # Handle case when multiple tickers result in multi-level columns
    if isinstance(data.columns, pd.MultiIndex):
        data = data['Adj Close']
    else:
        data = data['Adj Close'].to_frame()

    # Drop any missing data rows
    data = data.dropna()

    # Calculate monthly returns using percent change
    returns = data.pct_change().dropna()
    return returns

"""3. Define the Portfolio Simulation Function (Monte Carlo) with Rebalancing"""

#   Portfolio simulation with rebalancing ---
def simulate_portfolio_with_rebalancing(
    returns_df,
    weights,
    n_years=30,
    n_sims=1000,
    rebalance_frequency=12,  # number of months between rebalancing
    seed=42
):
    """
    Simulates a portfolio using historical mean and covariance, allowing for periodic rebalancing.
    """
    np.random.seed(seed)

    mu = returns_df.mean().values
    cov = returns_df.cov().values

    n_assets = len(weights)
    n_steps = n_years * 12  # monthly steps

    sims = np.zeros((n_sims, n_steps + 1))
    sims[:, 0] = 1  # Start with $1

    for i in range(n_sims):
        portfolio_value = [1]
        asset_values = np.array(weights) * portfolio_value[0]

        for t in range(n_steps):
            monthly_returns = np.random.multivariate_normal(mu, cov)
            asset_values *= (1 + monthly_returns)

            if (t + 1) % rebalance_frequency == 0:
                total_value = np.sum(asset_values)
                asset_values = total_value * np.array(weights)

            portfolio_value.append(np.sum(asset_values))

        sims[i, :] = portfolio_value

    return sims


# --- 4. Download returns and define weights ---
tickers = ["SPY", "TLT", "VNQ", "GLD"]
returns = download_data(tickers)

weights_balanced = [0.6, 0.3, 0.05, 0.05]  # Example: 60% stocks, 30% bonds, 5% RE, 5% gold

"""Fix"""

# Define the tickers you want to simulate
tickers = ["SPY", "TLT", "VNQ", "GLD"]

# Download historical monthly returns
returns = download_data(tickers)

# (Optional) Preview the returns data
returns.head()

"""*4*. Run the Simulation with Annual Rebalancing"""

# Define a sample balanced portfolio: 60% equity, 30% bonds, 10% alternatives
weights_balanced = [0.6, 0.3, 0.05, 0.05]  # SPY, TLT, VNQ, GLD

# Run the rebalanced simulation
sims_rebalanced = simulate_portfolio_with_rebalancing(
    returns_df=returns,
    weights=weights_balanced,
    n_years=30,
    n_sims=500,
    rebalance_frequency=12  # rebalance every 12 months
)

"""5. Plot  Simulated Rebalanced Portfolios"""

# Plot 20 sample simulations with rebalancing
plt.figure(figsize=(12, 6))
for i in range(20):
    plt.plot(sims_rebalanced[i], alpha=0.6)

plt.title("Rebalanced Portfolio Simulation (Balanced 60/30/10, Annual)")
plt.xlabel("Months")
plt.ylabel("Portfolio Value ($)")
plt.show()

"""6. Analyze the Ending Portfolio Values"""

# Final portfolio values after 30 years
final_vals = sims_rebalanced[:, -1]

print("Rebalanced Portfolio (Balanced 60/30/10):")
print(f"Mean Ending Value:      ${np.mean(final_vals):,.2f}")
print(f"Median Ending Value:    ${np.median(final_vals):,.2f}")
print(f"5th Percentile (worst): ${np.percentile(final_vals, 5):,.2f}")
print(f"95th Percentile (best): ${np.percentile(final_vals, 95):,.2f}")

# Plot histogram
plt.figure(figsize=(10, 5))
plt.hist(final_vals, bins=50, edgecolor='black')
plt.axvline(np.mean(final_vals), color='blue', linestyle='dashed', label='Mean')
plt.axvline(np.median(final_vals), color='green', linestyle='dashed', label='Median')
plt.title("Final Portfolio Value Distribution (30 Years)")
plt.xlabel("Portfolio Value ($)")
plt.ylabel("Frequency")
plt.legend()
plt.show()

"""Performance Metrics Calculator"""

def calculate_metrics(simulations, risk_free_rate=0.02):
    """
    Calculates performance metrics from simulated portfolio values.

    Parameters:
        simulations (ndarray): Simulated portfolio values (n_simulations x time_steps)
        risk_free_rate (float): Annual risk-free rate used for Sharpe ratio

    Returns:
        dict: Dictionary of performance metrics
    """
    n_months = simulations.shape[1] - 1  # Exclude starting value
    n_years = n_months / 12

    # Calculate monthly returns from portfolio values
    monthly_returns = simulations[:, 1:] / simulations[:, :-1] - 1

    # Final portfolio values (at end of simulation)
    final_values = simulations[:, -1]

    # Annualized return = geometric mean over n years
    annualized_returns = (final_values / simulations[:, 0])**(1 / n_years) - 1
    avg_annual_return = np.mean(annualized_returns)

    # Annualized volatility = std of monthly returns * sqrt(12)
    monthly_volatility = np.std(monthly_returns, axis=1)
    annualized_volatility = np.mean(monthly_volatility) * np.sqrt(12)

    # Sharpe ratio = (return - risk_free) / volatility
    sharpe_ratio = (avg_annual_return - risk_free_rate) / annualized_volatility if annualized_volatility > 0 else np.nan

    # Max drawdown per simulation
    def max_drawdown(path):
        peak = path[0]
        max_dd = 0
        for val in path:
            peak = max(peak, val)
            dd = (peak - val) / peak
            max_dd = max(max_dd, dd)
        return max_dd

    max_drawdowns = [max_drawdown(sim) for sim in simulations]
    avg_max_drawdown = np.mean(max_drawdowns)

    # Final value stats
    fv_mean = np.mean(final_values)
    fv_median = np.median(final_values)
    fv_p5 = np.percentile(final_values, 5)
    fv_p95 = np.percentile(final_values, 95)

    return {
        "Annualized Return (%)": round(avg_annual_return * 100, 2),
        "Annualized Volatility (%)": round(annualized_volatility * 100, 2),
        "Sharpe Ratio": round(sharpe_ratio, 2),
        "Avg Max Drawdown (%)": round(avg_max_drawdown * 100, 2),
        "Final Value (Mean)": round(fv_mean, 2),
        "Final Value (Median)": round(fv_median, 2),
        "Final Value (5th %tile)": round(fv_p5, 2),
        "Final Value (95th %tile)": round(fv_p95, 2)
    }

# Let's say you just ran:
# sims_rebalanced = simulate_portfolio_with_rebalancing(...)

metrics = calculate_metrics(sims_rebalanced)
for k, v in metrics.items():
    print(f"{k}: {v}")

"""Multiple Portfolio Strategy Simulation and Comparison

ðŸ“Œ Step 1: Defining Portfolio Strategies
"""

# List of strategies with labels and asset weights
portfolio_configs = [
    {"name": "Conservative", "weights": [0.3, 0.6, 0.05, 0.05]},  # SPY, TLT, VNQ, GLD
    {"name": "Balanced",     "weights": [0.6, 0.3, 0.05, 0.05]},
    {"name": "Aggressive",   "weights": [0.8, 0.1, 0.05, 0.05]},
    {"name": "Equal Weight", "weights": [0.25, 0.25, 0.25, 0.25]}
]

"""ðŸ“Œ Step 2: Creating Multi-Strategy Comparison Function"""

def run_portfolio_comparison(configs, returns_df, n_years=30, n_sims=500, rebalance_frequency=12):
    """
    Simulates and compares multiple portfolio strategies.

    Parameters:
        configs (list): List of portfolio configs with 'name' and 'weights'
        returns_df (DataFrame): Historical return data
        n_years (int): Simulation horizon
        n_sims (int): Number of Monte Carlo simulations per portfolio
        rebalance_frequency (int): Rebalance interval in months

    Returns:
        results_df (DataFrame): Summary metrics for all strategies
        sim_results (dict): Simulations per strategy
    """
    results = []
    sim_results = {}

    for config in configs:
        print(f"Running: {config['name']}")
        sims = simulate_portfolio_with_rebalancing(
            returns_df=returns_df,
            weights=config['weights'],
            n_years=n_years,
            n_sims=n_sims,
            rebalance_frequency=rebalance_frequency
        )

        # Store simulation results for later plotting
        sim_results[config['name']] = sims

        # Compute performance metrics
        metrics = calculate_metrics(sims)
        metrics["Strategy"] = config["name"]
        results.append(metrics)

    # Convert results to DataFrame
    results_df = pd.DataFrame(results)
    return results_df.set_index("Strategy"), sim_results

"""ðŸ“Œ Step 3: Run the Comparison"""

results_df, simulations_dict = run_portfolio_comparison(
    configs=portfolio_configs,
    returns_df=returns,
    n_years=30,
    n_sims=500,
    rebalance_frequency=12
)

"""ðŸ“Œ Step 4: Results"""

# View the full comparison table
results_df.sort_values("Annualized Return (%)", ascending=False)

"""ðŸ“ˆ Step 5: Visualize the Comparison"""

plt.figure(figsize=(10, 6))

# Scatter plot: Risk vs. Return
sns.scatterplot(
    data=results_df,
    x="Annualized Volatility (%)",
    y="Annualized Return (%)",
    hue=results_df.index,
    palette="Set2",
    s=150,
    edgecolor='black',
    linewidth=1
)

# Improve layout
plt.title("Risk vs Return (30-Year Simulations)", fontsize=16)
plt.xlabel("Annualized Volatility (%)", fontsize=12)
plt.ylabel("Annualized Return (%)", fontsize=12)
plt.axhline(0, color='gray', linestyle='--', linewidth=0.8)
plt.grid(True, linestyle='--', alpha=0.6)

# Legend formatting
plt.legend(title="Strategy", bbox_to_anchor=(1.05, 1), loc='upper left')

# Optional: Annotate each point with strategy name
for i, (strategy, row) in enumerate(results_df.iterrows()):
    plt.text(
        row["Annualized Volatility (%)"] + 0.2,
        row["Annualized Return (%)"],
        strategy,
        fontsize=9
    )

plt.tight_layout()
plt.show()

"""ðŸ“Š Violin Plot Distribution and Median of Final Values"""

# Prepare DataFrame of final values from all strategies
final_vals_df = pd.DataFrame({
    name: sims[:, -1] for name, sims in simulations_dict.items()
})
plt.figure(figsize=(10, 6))
sns.violinplot(data=final_vals_df, inner="quartile", palette="Set2")
plt.title("Distribution of Final Portfolio Values (30 Years)", fontsize=14)
plt.ylabel("Final Value ($)", fontsize=12)
plt.xlabel("Strategy", fontsize=12)
plt.grid(True, linestyle="--", alpha=0.6)
plt.show()

"""Building a Mean-Variance Optimizer (MVO)

ðŸ“¦ Step 1: Install & Import PyPortfolioOpt
"""

!pip install PyPortfolioOpt --quiet

# Imports from the PyPortfolioOpt library
from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import sample_cov
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt.objective_functions import L2_reg

"""ðŸ“ Step 2: Preparing Data (Expected Returns & Covariance)"""

from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import sample_cov

# ðŸ§¼ Fix the column name issue
returns.columns.name = None

# Tell the function we're passing returns, not prices
mu = mean_historical_return(returns, frequency=12, returns_data=True)
cov_matrix = sample_cov(returns, frequency=12)

mu, cov_matrix

# Clean column metadata
returns.columns.name = None

# Use PyPortfolioOpt for expected return (since this works fine)
mu = mean_historical_return(returns, frequency=12, returns_data=True)

# Use pandas for stable covariance matrix
cov_matrix = returns.cov() * 12

print(mu)
print(cov_matrix)

"""ðŸ§  Step 3: Build the Optimizer"""

from pprint import pprint

def display_portfolio(name, ef_object):
    print(f"\nðŸ“Œ {name}")
    performance = ef_object.portfolio_performance(verbose=True, risk_free_rate=0.02)
    weights = ef_object.clean_weights()
    print("Weights:")
    pprint(weights)
    return weights, performance

# ------------------------------
# ðŸŽ¯ Max Sharpe Ratio Portfolio
# ------------------------------
ef_max_sharpe = EfficientFrontier(mu, cov_matrix)
ef_max_sharpe.max_sharpe(risk_free_rate=0.02)
weights_max_sharpe, perf_max_sharpe = display_portfolio("Max Sharpe Portfolio", ef_max_sharpe)

# ------------------------------
# ðŸ” Minimum Volatility Portfolio
# ------------------------------
ef_min_vol = EfficientFrontier(mu, cov_matrix)
ef_min_vol.min_volatility()
weights_min_vol, perf_min_vol = display_portfolio("Minimum Volatility Portfolio", ef_min_vol)

# ------------------------------
# ðŸŽ¯ Target Return Portfolio (8%)
# ------------------------------
ef_target_return = EfficientFrontier(mu, cov_matrix)
ef_target_return.efficient_return(target_return=0.08)
weights_target_return, perf_target_return = display_portfolio("Target Return Portfolio (8%)", ef_target_return)

"""ðŸ“ Step 4: Using Optimized Weights in The Simulator"""

from collections import OrderedDict
from pprint import pprint

# === 1. Optimize portfolio for Max Sharpe Ratio ===
ef_max_sharpe = EfficientFrontier(mu, cov_matrix)
ef_max_sharpe.max_sharpe(risk_free_rate=0.02)

# Clean weights and store
weights_max_sharpe = ef_max_sharpe.clean_weights()

# === 2. Get performance of optimized portfolio ===
expected_return, volatility, sharpe_ratio = ef_max_sharpe.portfolio_performance(verbose=False, risk_free_rate=0.02)

# === 3. Run simulation using optimized weights ===
assets = list(returns.columns)
weights_list = [weights_max_sharpe[ticker] for ticker in assets]

sims_opt = simulate_portfolio_with_rebalancing(
    returns_df=returns,
    weights=weights_list,
    n_years=30,
    n_sims=500,
    rebalance_frequency=12
)

# === 4. Calculate simulation-based metrics ===
metrics = calculate_metrics(sims_opt)

# === 5. Display Results ===
print("ðŸ“Œ Max Sharpe Portfolio")
print(f"Expected annual return: {round(expected_return * 100, 2)}%")
print(f"Annual volatility: {round(volatility * 100, 2)}%")
print(f"Sharpe Ratio: {round(sharpe_ratio, 2)}")
print("Weights:")
pprint(OrderedDict({ticker: round(weights_max_sharpe[ticker], 5) for ticker in assets}))

print("\nðŸ“Š Simulation-Based Metrics (30-Year Monte Carlo)")
for k, v in metrics.items():
    print(f"{k}: {v}")

"""ðŸ“ˆ Step 5.  Allocations"""

# ðŸ“ Step 5: Optimized Allocation (Bar Plot)

# ðŸ“Š Slim bar plot for optimized weights
fig, ax = plt.subplots(figsize=(6, 3.5))

# Use updated variable name
labels = list(weights_max_sharpe.keys())
values = list(weights_max_sharpe.values())

# Plot with thinner bars
bars = ax.bar(labels, values, width=0.4, color=sns.color_palette("Pastel1"))

# Add percentage labels above bars
for bar in bars:
    height = bar.get_height()
    ax.text(
        bar.get_x() + bar.get_width() / 2,
        height + 0.01,
        f"{height:.1%}",
        ha="center",
        va="bottom",
        fontsize=9
    )

# Style
ax.set_title("Optimized Portfolio Weights (Max Sharpe)", fontsize=12, pad=10)
ax.set_ylabel("Weight", fontsize=10)
ax.set_ylim(0, 1)
ax.grid(axis="y", linestyle="--", alpha=0.5)
sns.despine()

plt.tight_layout()
plt.show()

"""One Question: Can my protfolio survive a crisis?

**Stress Testing**

I am going to build 2 historical scenario tests. First one is 2008 crisis, scond one is COVID.

1. 2008 Crisis

ðŸ“Œ Step 1: Choose a Historical Period
"""

# Download adjusted prices during 2008 crisis period (monthly frequency)
crisis_data = yf.download(
    ["SPY", "TLT", "VNQ", "GLD"],
    start="2007-01-01",
    end="2010-01-01",
    interval="1mo",
    auto_adjust=False  # Keep same style as rest of project
)

# Extract 'Adj Close' (adjusted for dividends/splits)
if isinstance(crisis_data.columns, pd.MultiIndex):
    crisis_data = crisis_data['Adj Close']
else:
    crisis_data = crisis_data['Adj Close'].to_frame()

# Drop any rows with missing values
crisis_data = crisis_data.dropna()

# Calculate monthly returns
crisis_returns = crisis_data.pct_change().dropna()

"""ðŸ“Œ Step 2: Define Portfolio Weights"""

# ðŸ§® Step 2: Define All Portfolio Weights for Crisis Testing

# Make sure asset order is consistent
crisis_assets = list(crisis_returns.columns)

# === Predefined static portfolios ===
weights_equal = [0.25, 0.25, 0.25, 0.25]
weights_conservative = [0.10, 0.60, 0.20, 0.10]
weights_balanced = [0.60, 0.30, 0.05, 0.05]
weights_aggressive = [0.80, 0.10, 0.05, 0.05]

# === Optimized portfolios (from your optimizer step)
weights_max_sharpe_list = [weights_max_sharpe[ticker] for ticker in crisis_assets]
weights_min_vol_list = [weights_min_vol[ticker] for ticker in crisis_assets]
weights_target_return_list = [weights_target_return[ticker] for ticker in crisis_assets]

# âœ… Store all portfolios in a dictionary
crisis_weights_dict = {
    "Equal Weight": weights_equal,
    "Conservative": weights_conservative,
    "Balanced": weights_balanced,
    "Aggressive": weights_aggressive,
    "Optimized (Max Sharpe)": weights_max_sharpe_list,
    "Min Volatility": weights_min_vol_list,
    "Target Return (8%)": weights_target_return_list
}

"""ðŸ“Œ Step 3: Apply the Crisis Returns to the Portfolio"""

# ðŸ› ï¸ Function (already defined)
def simulate_historical_scenario(returns_df, weights):
    """
    Simulates portfolio performance by applying actual historical returns
    (e.g., during a crisis period).
    """
    weights = np.array(weights)
    portfolio_returns = returns_df @ weights  # Dot product: weighted return per month
    portfolio_values = [1]  # Start at $1

    for r in portfolio_returns:
        portfolio_values.append(portfolio_values[-1] * (1 + r))

    return portfolio_values


# ðŸš€ Simulate all portfolios
crisis_simulations = {}

for name, weights in crisis_weights_dict.items():
    values = simulate_historical_scenario(crisis_returns, weights)
    crisis_simulations[name] = values

"""ðŸ“Œ Step 4: Run and Plot the Scenario for all Portfolios 01.2007-12.2009"""

# ðŸ“ˆ Plot all simulated portfolios during the crisis
  plt.figure(figsize=(10, 6))

  for name, values in crisis_simulations.items():
      plt.plot(values, label=name)

  # Plot settings
  plt.title(" Portfolio Performance During 2008 Financial Crisis", fontsize=14)
  plt.xlabel("Months (2007â€“2009)", fontsize=12)
  plt.ylabel("Portfolio Value ($)", fontsize=12)
  plt.grid(True, linestyle="--", alpha=0.6)
  plt.legend(title="Strategy", fontsize=9)
  plt.tight_layout()
  plt.show()

"""ðŸ“‰ Scenario for all Portfolios 08.2008-03.2009"""

# STEP 1: Download price data for the stress period
stress_data = yf.download(["SPY", "TLT", "VNQ", "GLD"],
                          start="2008-07-01",
                          end="2009-04-01",
                          interval="1mo",
                          auto_adjust=False)

# STEP 2: Extract 'Adj Close' prices
if isinstance(stress_data.columns, pd.MultiIndex):
    stress_data = stress_data['Adj Close']
else:
    stress_data = stress_data['Adj Close'].to_frame()

# STEP 3: Drop rows with missing values and calculate returns
stress_data = stress_data.dropna()
stress_returns = stress_data.pct_change().dropna()

# STEP 4: Define all portfolio weights (same as earlier)
stress_portfolios = {
    "Equal Weight": [0.25, 0.25, 0.25, 0.25],
    "Balanced (60/30/10)": [0.6, 0.3, 0.05, 0.05],
    "Conservative (40/50/10)": [0.4, 0.5, 0.05, 0.05],
    "Aggressive (80/15/5)": [0.8, 0.15, 0.03, 0.02],
    "Optimized (Max Sharpe)": [weights_max_sharpe[t] for t in stress_returns.columns],
    "Min Volatility": [weights_min_vol[t] for t in stress_returns.columns],
    "Target Return (8%)": [weights_target_return[t] for t in stress_returns.columns],
}

# STEP 5: Simulate each during the stress period
stress_simulations = {}
for name, weights in stress_portfolios.items():
    values = simulate_historical_scenario(stress_returns, weights)
    stress_simulations[name] = values

# STEP 6: Plot results
plt.figure(figsize=(10, 6))
for name, values in stress_simulations.items():
    plt.plot(values, label=name)

plt.title(" Portfolio Performance: Jul 2008 â€“ Mar 2009 Stress Test", fontsize=14)
plt.xlabel("Months", fontsize=12)
plt.ylabel("Portfolio Value ($)", fontsize=12)
plt.grid(True, linestyle="--", alpha=0.6)
plt.legend(title="Strategy", fontsize=9)
plt.tight_layout()
plt.show()

"""ðŸ“‰ STEP 5: Calculate Drawdown During Crisis"""

import numpy as np
import matplotlib.pyplot as plt

# --- Max Drawdown Function ---
def calculate_max_drawdown(series):
    peak = series[0]
    max_dd = 0
    for val in series:
        peak = max(peak, val)
        dd = (peak - val) / peak
        max_dd = max(max_dd, dd)
    return max_dd

# --- Compute Drawdowns (may already be done earlier) ---
full_crisis_drawdowns = {
    name: calculate_max_drawdown(values)
    for name, values in crisis_simulations.items()
}

deep_crisis_drawdowns = {
    name: calculate_max_drawdown(values)
    for name, values in stress_simulations.items()
}

# --- Unified list of all portfolio names ---
all_strategies = sorted(set(full_crisis_drawdowns.keys()) | set(deep_crisis_drawdowns.keys()))

# --- Create aligned drawdown lists ---
dd_full = [full_crisis_drawdowns.get(s, np.nan) * 100 for s in all_strategies]
dd_deep = [deep_crisis_drawdowns.get(s, np.nan) * 100 for s in all_strategies]

# --- Plot Grouped Vertical Bar Chart ---
x = np.arange(len(all_strategies))  # label positions
width = 0.35  # width of each bar

fig, ax = plt.subplots(figsize=(12, 6))

bars1 = ax.bar(x - width/2, dd_full, width, label="Full Crisis (2007â€“2010)", color="crimson", alpha=0.8)
bars2 = ax.bar(x + width/2, dd_deep, width, label="Deep Crisis (Jul 2008â€“Mar 2009)", color="darkorange", alpha=0.8)

# Labels and title
ax.set_ylabel("Max Drawdown (%)", fontsize=12)
ax.set_title("Portfolio Max Drawdowns: Full vs. Deep 2008 Crisis", fontsize=14)
ax.set_xticks(x)
ax.set_xticklabels(all_strategies, rotation=45, ha='right')
ax.legend()
ax.grid(True, linestyle="--", alpha=0.5, axis='y')

# Add values above bars
def annotate_bars(bars):
    for bar in bars:
        height = bar.get_height()
        if not np.isnan(height):
            ax.annotate(f'{height:.1f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),  # offset
                        textcoords="offset points",
                        ha='center', va='bottom', fontsize=9)


# Optional: Map verbose names to standard ones
name_map = {
    "Aggressive (80/15/5)": "Aggressive",
    "Balanced (60/30/10)": "Balanced",
    "Conservative (40/50/10)": "Conservative"
}

# Apply mapping to simulation dictionaries
def remap_keys(d, mapping):
    return {mapping.get(k, k): v for k, v in d.items()}

crisis_simulations = remap_keys(crisis_simulations, name_map)
stress_simulations = remap_keys(stress_simulations, name_map)


annotate_bars(bars1)
annotate_bars(bars2)

plt.tight_layout()
plt.show()

"""2. COVID Crisis

ðŸ“Œ Step 1: Choose a Historical Period
"""

import yfinance as yf
import pandas as pd

# Download adjusted prices during COVID crisis period (monthly frequency)
covid_data = yf.download(
    ["SPY", "TLT", "VNQ", "GLD"],
    start="2019-12-01",
    end="2020-08-01",
    interval="1mo",
    auto_adjust=False
)

# Extract 'Adj Close'
if isinstance(covid_data.columns, pd.MultiIndex):
    covid_data = covid_data['Adj Close']
else:
    covid_data = covid_data['Adj Close'].to_frame()

# Drop missing values and calculate monthly returns
covid_data = covid_data.dropna()
covid_returns = covid_data.pct_change().dropna()

"""ðŸ“Œ Step 2: Define Portfolio Weights"""

# ðŸ§® Step 2: Define All Portfolio Weights for COVID Crisis Testing

# Ensure asset order matches the columns in the returns dataframe
covid_assets = list(covid_returns.columns)

# === Predefined static portfolios ===
weights_equal = [0.25, 0.25, 0.25, 0.25]
weights_conservative = [0.10, 0.60, 0.20, 0.10]
weights_balanced = [0.60, 0.30, 0.05, 0.05]
weights_aggressive = [0.80, 0.10, 0.05, 0.05]

# === Optimized portfolios (from your MVO step)
weights_max_sharpe_list = [weights_max_sharpe[ticker] for ticker in covid_assets]
weights_min_vol_list = [weights_min_vol[ticker] for ticker in covid_assets]
weights_target_return_list = [weights_target_return[ticker] for ticker in covid_assets]

# âœ… Store all portfolios in a dictionary
covid_weights_dict = {
    "Equal Weight": weights_equal,
    "Conservative": weights_conservative,
    "Balanced": weights_balanced,
    "Aggressive": weights_aggressive,
    "Optimized (Max Sharpe)": weights_max_sharpe_list,
    "Min Volatility": weights_min_vol_list,
    "Target Return (8%)": weights_target_return_list
}

"""ðŸ“Œ Step 3: Apply the Crisis Returns to the Portfolio"""

# ðŸš€ Simulate all portfolios during the COVID crisis
covid_simulations = {}

for name, weights in covid_weights_dict.items():
    values = simulate_historical_scenario(covid_returns, weights)
    covid_simulations[name] = values

"""ðŸ“Œ Step 4: Run and Plot the Scenario for all Portfolios"""

import matplotlib.pyplot as plt

# ðŸ“ˆ Plot all simulated portfolios during the COVID crisis
plt.figure(figsize=(10, 6))

for name, values in covid_simulations.items():
    plt.plot(values, label=name)

# Plot settings
plt.title("Portfolio Performance During COVID-19 Crisis (Dec 2019 â€“ Jul 2020)", fontsize=14)
plt.xlabel("Months", fontsize=12)
plt.ylabel("Portfolio Value ($)", fontsize=12)
plt.grid(True, linestyle="--", alpha=0.6)
plt.legend(title="Strategy", fontsize=9)
plt.tight_layout()
plt.show()

"""ðŸ“‰ STEP 5: Calculate Drawdown During Crisis"""

import numpy as np
import matplotlib.pyplot as plt

# --- Max Drawdown Function ---
def calculate_max_drawdown(series):
    peak = series[0]
    max_dd = 0
    for val in series:
        peak = max(peak, val)
        dd = (peak - val) / peak
        max_dd = max(max_dd, dd)
    return max_dd

# --- Optional: Clean up portfolio names ---
name_map = {
    "Aggressive (80/15/5)": "Aggressive",
    "Balanced (60/30/10)": "Balanced",
    "Conservative (40/50/10)": "Conservative"
}

def remap_keys(d, mapping):
    return {mapping.get(k, k): v for k, v in d.items()}

covid_simulations = remap_keys(covid_simulations, name_map)

# --- Compute Drawdowns ---
covid_drawdowns = {
    name: calculate_max_drawdown(values)
    for name, values in covid_simulations.items()
}

# --- Prepare data for plotting ---
strategies = sorted(covid_drawdowns.keys())
dd_values = [covid_drawdowns[s] * 100 for s in strategies]

# --- Plot Bar Chart ---
x = np.arange(len(strategies))
fig, ax = plt.subplots(figsize=(10, 6))

bars = ax.bar(x, dd_values, color="steelblue", alpha=0.85)

# Formatting
ax.set_title("Max Drawdowns During COVID-19 Crisis (Dec 2019 â€“ Jul 2020)", fontsize=14)
ax.set_ylabel("Max Drawdown (%)", fontsize=12)
ax.set_xticks(x)
ax.set_xticklabels(strategies, rotation=45, ha='right')
ax.grid(True, linestyle="--", alpha=0.5, axis='y')

# Annotate values
for bar in bars:
    height = bar.get_height()
    if not np.isnan(height):
        ax.annotate(f'{height:.1f}%',
                    xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, 3),
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

"""Building Synthetic Shock Simulator

ðŸ“¦ Step 1: Defining Synthetic Monthly Return Series and Running The Simulation
"""

def create_synthetic_shock_scenario(shock_returns, recovery_returns, n_recovery_months=12):
    """
    Creates a synthetic monthly return sequence: 1-month shock + N-month recovery.
    """
    tickers = list(shock_returns.keys())

    # Shock (1 row)
    shock_df = pd.DataFrame([shock_returns], columns=tickers)

    # Recovery (n rows)
    recovery_df = pd.DataFrame([recovery_returns] * n_recovery_months, columns=tickers)

    # Combine
    synthetic_returns = pd.concat([shock_df, recovery_df], ignore_index=True)
    return synthetic_returns


def simulate_synthetic_shock_for_all_portfolios(synthetic_returns, portfolio_weights_dict):
    """
    Applies synthetic return sequence to all portfolios and tracks portfolio value over time.

    Parameters:
        synthetic_returns (DataFrame): Synthetic scenario (monthly returns per asset)
        portfolio_weights_dict (dict): Dict of {portfolio_name: weights}

    Returns:
        dict: {portfolio_name: [portfolio_value_series]}
    """
    simulations = {}

    for name, weights in portfolio_weights_dict.items():
        weights = np.array(weights)
        portfolio_returns = synthetic_returns @ weights
        values = [1]  # Start at $1
        for r in portfolio_returns:
            values.append(values[-1] * (1 + r))
        simulations[name] = values

    return simulations


# === Example Usage ===

# Step 1: Define a shock and recovery pattern (you can change these)
shock = {
    "SPY": -0.25,
    "TLT": 0.04,
    "VNQ": -0.30,
    "GLD": 0.03
}

recovery = {
    "SPY": 0.015,
    "TLT": 0.005,
    "VNQ": 0.01,
    "GLD": 0.005
}

# Step 2: Create synthetic returns
synthetic_returns = create_synthetic_shock_scenario(shock, recovery, n_recovery_months=12)

# Step 3: Run simulation for all portfolios
synthetic_simulations = simulate_synthetic_shock_for_all_portfolios(synthetic_returns, covid_weights_dict)

# Step 4: Plot results
plt.figure(figsize=(10, 6))
for name, values in synthetic_simulations.items():
    plt.plot(values, label=name)

plt.title("Portfolio Performance Under Synthetic Shock + Recovery", fontsize=14)
plt.xlabel("Months", fontsize=12)
plt.ylabel("Portfolio Value ($)", fontsize=12)
plt.grid(True, linestyle="--", alpha=0.6)
plt.legend(title="Strategy", fontsize=9)
plt.tight_layout()
plt.show()

"""ðŸ“ˆ Step 2: Analyzing the Drawdown"""

# --- Max Drawdown Function ---
def calculate_max_drawdown(series):
    peak = series[0]
    max_dd = 0
    for val in series:
        peak = max(peak, val)
        dd = (peak - val) / peak
        max_dd = max(max_dd, dd)
    return max_dd

# --- Optional: Clean names if needed ---
name_map = {
    "Aggressive (80/15/5)": "Aggressive",
    "Balanced (60/30/10)": "Balanced",
    "Conservative (40/50/10)": "Conservative"
}

def remap_keys(d, mapping):
    return {mapping.get(k, k): v for k, v in d.items()}

synthetic_simulations = remap_keys(synthetic_simulations, name_map)

# --- Compute Drawdowns ---
synthetic_drawdowns = {
    name: calculate_max_drawdown(values)
    for name, values in synthetic_simulations.items()
}

# --- Plot Bar Chart of Max Drawdowns ---
import matplotlib.pyplot as plt
import numpy as np

# Prepare data
strategies = sorted(synthetic_drawdowns.keys())
dd_values = [synthetic_drawdowns[s] * 100 for s in strategies]

# Plot
x = np.arange(len(strategies))
fig, ax = plt.subplots(figsize=(10, 6))

bars = ax.bar(x, dd_values, color="firebrick", alpha=0.85)

# Formatting
ax.set_title("Max Drawdowns Under Synthetic Shock Scenario", fontsize=14)
ax.set_ylabel("Max Drawdown (%)", fontsize=12)
ax.set_xticks(x)
ax.set_xticklabels(strategies, rotation=45, ha='right')
ax.grid(True, linestyle="--", alpha=0.5, axis='y')

# Annotate values
for bar in bars:
    height = bar.get_height()
    if not np.isnan(height):
        ax.annotate(f'{height:.1f}%',
                    xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, 3),
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

"""ðŸ“ˆ Step3: Calculating Recovery Slope for All Portfolios"""

def calculate_recovery_slope(series):
    """
    Calculates the recovery slope from drawdown trough to full recovery (annualized).
    Returns NaN if no full recovery happens.
    """
    series = np.array(series)
    peak = series[0]
    peak_idx = 0
    trough_idx = 0
    recovery_idx = None
    max_dd = 0

    # Step 1: Identify peak and trough (max drawdown)
    for i, val in enumerate(series):
        if val > peak:
            peak = val
            peak_idx = i
        dd = (peak - val) / peak
        if dd > max_dd:
            max_dd = dd
            trough_idx = i

    # Step 2: Find recovery point (value reaches or exceeds peak)
    for i in range(trough_idx + 1, len(series)):
        if series[i] >= peak:
            recovery_idx = i
            break

    # Step 3: Compute slope if recovery happened
    if recovery_idx is not None:
        months = recovery_idx - trough_idx
        if months > 0:
            slope = (series[recovery_idx] / series[trough_idx])**(12 / months) - 1
            return slope
    return np.nan

# --- Compute Recovery Slopes ---
recovery_slopes = {
    name: calculate_recovery_slope(values)
    for name, values in synthetic_simulations.items()
}

# --- Plot Bar Chart ---
import matplotlib.pyplot as plt
import numpy as np

strategies = sorted(recovery_slopes.keys())
slope_values = [recovery_slopes[s] * 100 for s in strategies]

x = np.arange(len(strategies))
fig, ax = plt.subplots(figsize=(10, 6))

bars = ax.bar(x, slope_values, color="seagreen", alpha=0.85)

# Formatting
ax.set_title("Recovery Slopes After Synthetic Shock", fontsize=14)
ax.set_ylabel("Annualized Recovery Rate (%)", fontsize=12)
ax.set_xticks(x)
ax.set_xticklabels(strategies, rotation=45, ha='right')
ax.grid(True, linestyle="--", alpha=0.5, axis='y')

# Annotate bars
for bar in bars:
    height = bar.get_height()
    if not np.isnan(height):
        ax.annotate(f'{height:.1f}%',
                    xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, 3),
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

"""# Private Asset Modeling

In this chapter, I am going to build a class with the name "PrivateInvestment" to model illiquid investments such as Venture Capitals, Private Equities, and Real Assets.

âœ… STEP 1: Build a PrivateInvestment Class
"""

import numpy_financial as npf  # Needed for IRR

class PrivateInvestment:
    def __init__(
        self,
        commitment,
        start_month,
        fund_life=120,
        call_schedule=None,
        nav_growth_schedule=None,
        distribution_schedule=None
    ):
        """
        Models a private investment (e.g., VC or PE fund)

        Args:
            commitment (float): Total capital committed
            start_month (int): When the investment starts (month 0 = portfolio start)
            fund_life (int): Total fund life in months (default = 10 years)
            call_schedule (list): % of commitment called each month
            nav_growth_schedule (list): Monthly NAV multiplier
            distribution_schedule (list): Cash distributed back each month
        """
        self.commitment = commitment
        self.start_month = start_month
        self.fund_life = fund_life

        self.call_schedule = call_schedule or self.default_call_schedule()
        self.nav_growth_schedule = nav_growth_schedule or self.default_nav_growth()
        self.distribution_schedule = distribution_schedule or self.default_distributions()

        self.nav_history = []
        self.cash_flows = []

        self.simulate()

    def calculate_irr(self):
        """
        Uses numpy_financial.irr to compute internal rate of return.
        Cash flows already include capital calls (-) and distributions (+).
        """
        return npf.irr(self.cash_flows)

    def calculate_moic(self):
        """
        MOIC = Total distributions / Total capital called
        """
        total_called = sum([-cf for cf in self.cash_flows if cf < 0])
        total_distributed = sum([cf for cf in self.cash_flows if cf > 0])
        if total_called == 0:
            return 0
        return total_distributed / total_called

    def default_call_schedule(self):
        """
        Default: call 20% of capital per year over 5 years
        """
        schedule = [0] * self.fund_life
        for i in range(60):  # first 5 years
            schedule[i] = 0.2 / 60
        return schedule

    def default_nav_growth(self):
        """
        Simulates NAV buildup: J-curve shape
        """
        growth = [0] * self.fund_life
        for i in range(self.fund_life):
            if i < 24:
                growth[i] = 0.99  # early-stage NAV drag
            elif i < 60:
                growth[i] = 1.01  # slow growth
            else:
                growth[i] = 1.03  # acceleration phase
        return growth

    def default_distributions(self):
        """
        Simple: distributions begin after year 5 and ramp up
        """
        dist = [0] * self.fund_life
        for i in range(60, self.fund_life):  # start distributions after 5 years
            dist[i] = 0.02  # distribute 2% of commitment monthly
        return dist

    def simulate(self):
        """
        Run simulation: apply capital calls, NAV changes, distributions
        """
        nav = 0
        total_called = 0
        cash_flows = []
        navs = []

        for i in range(self.fund_life):
            call = self.call_schedule[i] * self.commitment
            total_called += call

            # Grow NAV from previous month
            nav = nav * self.nav_growth_schedule[i] + call

            # Distribute from NAV
            # dist = self.distribution_schedule[i] * self.commitment # I comment this line in order not to lose it.
            # I will replace it with t he following line.
            dist = self.distribution_schedule[i] * nav
            nav = max(nav - dist, 0)

            # Store values
            navs.append(nav)
            cash_flows.append(-call + dist)

        self.nav_history = navs
        self.cash_flows = cash_flows

# Create a $1M VC fund investment
vc_fund = PrivateInvestment(
    commitment=1_000_000,
    start_month=0,
    fund_life=120  # 10 years
)

# Plot NAV history
plt.figure(figsize=(10, 4))
plt.plot(vc_fund.nav_history)
plt.title("NAV Over Time")
plt.xlabel("Months")
plt.ylabel("NAV ($)")
plt.grid(True)
plt.show()

# Cumulative cash flow (for IRR)
cumulative_cf = np.cumsum(vc_fund.cash_flows)

plt.figure(figsize=(10, 4))
plt.plot(cumulative_cf)
plt.title("Cumulative Net Cash Flow (J-Curve)")
plt.xlabel("Months")
plt.ylabel("Cash Flow ($)")
plt.grid(True)
plt.axhline(0, color='black', linestyle='--')
plt.show()

"""ðŸ“ˆ STEP2: Adding IRR / MOIC calculator"""

# Create investment
vc_fund = PrivateInvestment(commitment=1_000_000, start_month=0)

# IRR
irr = vc_fund.calculate_irr()
print(f"IRR: {irr * 100:.2f}%")

# MOIC
moic = vc_fund.calculate_moic()
print(f"MOIC: {moic:.2f}x")

"""ðŸ”§ Unified Portfolio Simulator (Public+Private)

ðŸ“Œ Step 1: Define the Unified Simulator Function
"""

def simulate_total_portfolio(
    initial_capital,
    public_weights,
    returns_df,
    private_investments,
    n_months=120,
    cash_rate=0.02  # annual interest on unallocated cash
):
    """
    Simulates a total portfolio combining public assets, private investments, and a cash account.

    Parameters:
        initial_capital (float): Starting portfolio value
        public_weights (list): Allocation to public assets (must sum < 1.0 to leave room for privates)
        returns_df (DataFrame): Monthly return data for public assets
        private_investments (list): List of PrivateInvestment objects
        n_months (int): Total simulation period in months
        cash_rate (float): Annual yield on uninvested cash (default: 2%)

    Returns:
        dict: Time series of total portfolio value, public, private, and cash
    """
    assert len(public_weights) == returns_df.shape[1], "Weights must match number of public assets"

    # Initialize values
    public_value = initial_capital * sum(public_weights)
    cash_balance = initial_capital * (1 - sum(public_weights))
    public_values = [public_value]
    private_navs = [sum([pi.nav_history[0] for pi in private_investments])]
    cash_balances = [cash_balance]
    total_values = [public_value + private_navs[-1] + cash_balance]

    # Start simulation loop
    for month in range(1, n_months):
        # === Public Assets ===
        monthly_returns = returns_df.iloc[month % len(returns_df)].values
        public_value *= (1 + np.dot(public_weights, monthly_returns))
        public_values.append(public_value)

        # === Private Assets ===
        private_nav = 0
        net_private_cashflow = 0
        for pi in private_investments:
            if month < len(pi.cash_flows):
                private_nav += pi.nav_history[month]
                net_private_cashflow += pi.cash_flows[month]

        private_navs.append(private_nav)

        # === Cash Account ===
        cash_balance += net_private_cashflow
        cash_balance *= (1 + cash_rate / 12)  # accrue interest monthly
        cash_balances.append(cash_balance)

        # === Total Portfolio ===
        total = public_value + private_nav + cash_balance
        total_values.append(total)

    return {
        "public": public_values,
        "private": private_navs,
        "cash": cash_balances,
        "total": total_values
    }

"""ðŸ§ª Step 2: Run an Example Simulation"""

# Setup with Target Return Portfolio
initial_capital = 1_000_000
public_weights = [weights_target_return[t] for t in returns.columns]


# Create two private investments with different start dates
pi1 = PrivateInvestment(commitment=200_000, start_month=0)
pi2 = PrivateInvestment(commitment=100_000, start_month=12)

private_investments = [pi1, pi2]

# Run the simulation
portfolio_result = simulate_total_portfolio(
    initial_capital=initial_capital,
    public_weights=public_weights,
    returns_df=returns,  # historical monthly returns you already have
    private_investments=private_investments,
    n_months=120
)

"""ðŸ“ˆ Step 3: Plot Results"""

# Dynamically get the number of months
months = list(range(len(portfolio_result['public'])))
print("Target Return (8%) Portfolio Weights:")
pprint(dict(zip(returns.columns, public_weights)))

plt.figure(figsize=(12, 6))
plt.plot(months, portfolio_result['public'], label='Public Assets')
plt.plot(months, portfolio_result['private'], label='Private NAV')
plt.plot(months, portfolio_result['cash'], label='Cash')
plt.plot(months, portfolio_result['total'], label='Total Portfolio', linewidth=2)
plt.title("Unified Portfolio Simulation (Public + Private + Cash)")
plt.xlabel("Month")
plt.ylabel("Value ($)")
plt.legend()
plt.grid(True)
plt.show()
from pprint import pprint

"""Portfolio-Level Metrics Function"""

import numpy as np
import numpy_financial as npf

def calculate_total_portfolio_metrics(portfolio_result, initial_capital, risk_free_rate=0.02):
    """
    Calculates total portfolio-level performance metrics.
    """
    total_values = portfolio_result['total']
    public_values = portfolio_result['public']
    private_navs = portfolio_result['private']
    cash_balances = portfolio_result['cash']

    n_months = len(total_values) - 1
    n_years = n_months / 12

    # Annualized Return
    final_value = float(total_values[-1])
    annualized_return = (final_value / initial_capital) ** (1 / n_years) - 1

    # Monthly Returns
    monthly_returns = np.diff(total_values) / total_values[:-1]
    annualized_volatility = np.std(monthly_returns) * np.sqrt(12)

    # Sharpe Ratio
    sharpe_ratio = (annualized_return - risk_free_rate) / annualized_volatility if annualized_volatility > 0 else np.nan

    # Max Drawdown
    running_max = np.maximum.accumulate(total_values)
    drawdowns = (running_max - total_values) / running_max
    max_drawdown = np.max(drawdowns)

    # Cumulative Return
    cumulative_return = final_value / initial_capital - 1

    # Final Allocation (% of total)
    total_final = final_value
    public_pct = public_values[-1] / total_final
    private_pct = private_navs[-1] / total_final
    cash_pct = cash_balances[-1] / total_final

    # IRR
    cash_flows = [-initial_capital] + list(np.diff(total_values))
    irr = npf.irr(cash_flows)

    # Format all values as clean Python floats
    return {
        "Final Portfolio Value ($)": round(float(final_value), 2),
        "Cumulative Return (%)": round(float(cumulative_return) * 100, 2),
        "Annualized Return (%)": round(float(annualized_return) * 100, 2),
        "Annualized Volatility (%)": round(float(annualized_volatility) * 100, 2),
        "Sharpe Ratio": round(float(sharpe_ratio), 2),
        "Max Drawdown (%)": round(float(max_drawdown) * 100, 2),
        "Portfolio IRR (%)": round(float(irr) * 100, 2),
        "Final Allocation - Public (%)": round(float(public_pct) * 100, 2),
        "Final Allocation - Private (%)": round(float(private_pct) * 100, 2),
        "Final Allocation - Cash (%)": round(float(cash_pct) * 100, 2)
    }

"""ðŸ§ª Example Usage"""

metrics = calculate_total_portfolio_metrics(portfolio_result, initial_capital=1_000_000)

from pprint import pprint
pprint(metrics)

